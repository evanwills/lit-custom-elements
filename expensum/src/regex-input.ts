/** Globals Error */
import { html, css, LitElement, } from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('regex-input')
export class RegexInput extends LitElement {
  /**
   * Predefined RegExp string
   *
   * @var maxlength
   */
  @property({ reflect: true })
  value : string = '';

  /**
   * Predefined RegExp flags
   *
   * @var maxlength
   */
  @property({ reflect: true })
  flags : string = 'ig';

  /**
   * RegExp Flags allowed by the client
   *
   * @var maxlength
   */
  @property()
  allowedflags : string = '';

  /**
   * The maximum number of characters a regular expression is
   * allowed to be
   *
   * @var maxlength
   */
  @property()
  maxlength : number = 512;

  /**
   * Hide the flags input field
   *
   * @var noFlags
   */
  @property()
  noFlags : boolean = false;

  /**
   * Hide the flags input field
   *
   * @var noFlags
   */
  @property()
  noDelims : boolean = false;

  /**
   * Regular expression delimiter (for non-JS regex engines)
   *
   * @var delim
   */
  @property()
  delim : string = '/';

  /**
   *
   * @var fieldid
   */
  @property()
  fieldid : string = '';

  /**
   * Does the regex have any errors
   *
   * @var hasError
   */
  hasError : boolean = false;

  /**
   * Whole regex string including delimiters & flags
   *
   * @var wholeRegex
   */
  wholeRegex : string = '';

  /**
   * Opening delimiter character
   *
   * (only relevant when used for non JS regex engines)
   *
   * @var _delimOpen
   */
  _delimOpen : string = '/';

  /**
   * Closing delimiter character
   *
   * (only relevant when used for non JS regex engines)
   *
   * @var _delimOpen
   */
  _delimClose : string = '/';

  /**
   * Number REMs wide the regex input field should be
   *
   * @var _regexSize
   */
  _regexSize : number = 8;

  /**
   * The number of REMs wide the flags input field should be
   *
   * @var _flagSize
   */
  _flagSize : number = 2;

  /**
   * List of allowed regex flags
   *
   * @var _alloweFlags
   */
  _alloweFlags : Array<string> = ['d', 'g', 'i', 'm', 's', 'u', 'y'];

  /**
   * List of custom regex flags (if set by the client)
   *
   * @var _customAllowedFlags
   */
  _customAllowedFlags : Array<string> = this._alloweFlags

  static styles = css`
    :host {
      --ri-font-size: 1rem;
      --ri-border-radius: var(--border-radius, 0.75rem);
      --ri-text-colour: var(--txt-colour, #fff);
      --ri-bg-colour: var(--bg-colour, rgb(0, 85, 34));

      font-size: 1rem;
      background-color: var(--ri-bg-colour, inherit);
      color:  var(--ri-text-colour, inherit);
      font-family: inherit;
      font-size: inherit;
    }
    .sr-only {
      border: 0;
      clip: rect(0, 0, 0, 0);
      clip-path: inset(100%);
      height: 1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      white-space: nowrap;
      width: 1px;
    }
    .wrap {
      backgroud-color: var(--ri-bg-colour);
      color: var(--ri-text-colour);
      border: var(--ri-line-weight, 0.05rem) solid var(--ri-text-colour, #ccc);
      border-radius: 0.75rem;
      display: inline-flex;
      font-family: 'Courier New', Courier, monospace;
      font-size: 1.1rem;
      font-weight: bold;
      overflow: hidden;
      padding: 0 0.4rem;
    }
    .wrap:focus-within {
      outline: 0.25rem dotted var(--ri-text-colour);
      outline-offset: 0.2rem;
    }
    input {
      background-color: var(--ri-bg-colour);
      color: var(--ri-text-colour);
      display: inline-block;
      font-family: 'Courier New', Courier, monospace;
      border: none;
      font-size: 1.1rem;
      transition: width ease-in-out 0.2s;
      width: auto;
    }
    .regex-flags {
      width: 4rem;
    }
    .field__value {
      border: none;
      display: inline-block;
      font-family: 'Courier New', Courier, monospace;
      width: 6rem;
      background-color: transparent;
      color: var(--ri-text-colour);
      transform: translateY(0) !important;
    }
    .field__value:invalid {
      font-weight: bold;
      color: #c00;
    }
    .field__value--first {
      text-align: center;
    }
    .field__value--sm {
      width: 4.5rem !important;
    }
    .field__value:invalid + .field__unit--last {
      font-weight: bold;
      color: #c00;
    }
    .field__unit {
    }
    .field__unit--last {
      padding-left: 0.3rem;
    }
    .field__unit--first {
      padding-right: 0.2rem;
    }
  `;

  /**
   * List of errors generated by invalid or duplicate flag characters
   *
   * @var flagErrors
   */
  _flagErrors : Array<string> = [];

  /**
   * Error generated by an invalid regular expression
   *
   * @var regexError
   */
  regexError : string = '';

  /**
   * Whether or not initialisation of functions and values is
   * alrady done
   *
   * @var initDone
   */
  initDone : boolean = false;

  //  END:  Property declarations
  // --------------------------------------------
  // START: Private helper methods

  /**
   * Do all the work to initialise everything
   *
   * @returns {void}
   */
  _doInit () {
    if (this.initDone === false) {
      this.initDone = true;
      if (this.allowedflags !== '') {
        const tmp = this._cleanFlags(this.allowedflags);
        const c = this._flagErrors.length
        if (c > 0) {
          for (let a = 0; a < c; a += 1) {
            // Log this to console to let the dev know they've
            // stuffed up
            console.error(this._flagErrors[a]);
          }
          // reset flag errors because these errros are only relevant
          // to the developer
          this._flagErrors = [];
        } else if (tmp.length > 0) {
          this.allowedflags = tmp;
          this._customAllowedFlags = Array.from(tmp);
        }
      }
      if (this.flags !== '') {
        // make sure the incoming flags are OK
        this.flags = this._cleanFlags(this.flags);
      }
      if (this.value !== '') {
        // Test the incoming regex
        this._regexIsValid(this.value, this.flags);
      }
      if (this.delim !== '' && this.delim !== '/') {
        const tmp = this.delim.trim().substring(0, 1);

        if (/^[\\a-z0-9 ]$/.test(tmp)) {
          console.error(`"${tmp}" is not a valid delimiter`)
        } else {
          switch (tmp) {
            case '{':
            case '}':
              this._delimOpen = '{';
              this._delimOpen = '}';
              break;

            case '(':
            case ')':
              this._delimOpen = '(';
              this._delimOpen = ')';
              break;

            case '[':
            case ']':
              this._delimOpen = '[';
              this._delimOpen = ']';
              break;

            case '<':
            case '>':
              this._delimOpen = '<';
              this._delimOpen = '>';
              break;

            default:
              this._delimOpen = tmp;
              this._delimClose = tmp;
          }
        }
      }
    }
    this._setWholeRegex()
  }

  /**
   * Strip invalid flags and remove duplicate flags
   *
   * @param input Flags string
   *
   * @returns String without duplicate or invalid flags
   */
  _cleanFlags (input : string) : string {
    const allowed = [ 'd', 'g', 'i', 'm', 's', 'u', 'y']
    const tmp1 : Array<string> = Array.from(input)
    let tmp2 : Array<string> = [];
    let output : string = '';
    const errors : Array<string> = [];

    for (let a = 0; a < tmp1.length; a += 1) {
      if (allowed.indexOf(tmp1[a]) > -1) {
        if (tmp2.indexOf(tmp1[a]) === -1) {
          tmp2.push(tmp1[a])
        } else {
          errors.push(`"${tmp1[a]}" was already listed as a flag this one will be removed`)
        }
      } else {
        errors.push(`"${tmp1[a]}" is not a valid flag so it will be removed`)
      }
    }
    this._flagErrors = errors;

    for (let a = 0; a < tmp2.length; a += 1) {
      output += tmp2[a];
    }

    return output;
  }

  /**
   * Get the length the input field should be (in REMs)
   *
   * @param len the number characters in a string
   * @param min Minimum value for output
   * @param max Maximum value for output
   *
   * @returns Number of REMs wide the input field should be
   */
  _getSize (len : number, min: number, max : number) : number {
    const tmp = Math.round((len * 0.675) * 100) / 100;
    if (tmp < min) {
      return min;
    } else if (tmp > max) {
      return max;
    } else {
      return tmp;
    }
  }

  /**
   * Build the full regex string including delimiters
   */
  _setWholeRegex () : void {
    this.wholeRegex = this._delimOpen + this.value +
                      this._delimClose + this.flags;
  }

  /**
   * Check whether the regex & flags are valid
   *
   * @param regexStr RegExp string
   * @param flagsStr Regexp modifier flags string
   *
   * @returns TRUE if regex is valid. FALSE otherwise
   */
  _regexIsValid (regexStr : string, flagsStr : string) : boolean {
    let regex : RegExp;

    try {
      regex = new RegExp(regexStr, flagsStr)
    } catch (e : any) {
      // Regex has an error lets deal with that
      this.hasError = true;
      this.regexError = e.message;

      return false;
    }

    // All good
    return true;
  }

  //  END:  Private helper methods
  // --------------------------------------------
  // START: Event handler methods

  /**
   * Event handler for regex field key up events
   *
   * (Used for updating the width of the input field)
   *
   * @param event
   */
  valueKeyup (event : Event) : void {
    event.preventDefault()
    const input = event.target as HTMLInputElement;
    const tmp = this._getSize(input.value.length, 8, 30);

    if (tmp !== this._regexSize) {
      this._regexSize = tmp;
      this.requestUpdate();
    }
  }

  /**
   * Event handler function for regex field change events
   *
   * (Used for letting the outside world know the regex has changed
   * and is valid)
   *
   * @param event
   */
  valueChange (event : Event) : void {
    event.preventDefault()
    const input = event.target as HTMLInputElement;
    const tmp = input.value;

    if (tmp !== this.value) {
      // We have a new regex string to work with.

      if (tmp !== '') {
        if (!this._regexIsValid(tmp, this.flags)) {
          this.requestUpdate();
        }
      }
      // Regex is empty so cannot have an error
      this.hasError = false;
      this._setWholeRegex()
      if (this.regexError !== '') {
        // We no longer have an error message so we'd better update
        // the UI
        this.regexError = '';
        this.requestUpdate();
      }

      // Let the outside world know there's something new to work with.
      this.dispatchEvent(
        new Event('change', { bubbles: true, composed: true })
      );
    }
  }

  /**
   * Event handler function for flag field Key Up events
   * (used for adjusting the width)
   *
   * @param event
   */
  flagKeyup (event: Event) : void {
    event.preventDefault()
    const input = event.target as HTMLInputElement;
    const value = this._cleanFlags(input.value)
    const tmp = this._getSize(value.length, 2, 5);
    let doUpdate = false;

    if (tmp !== this._flagSize) {
      this._flagSize = tmp;
      doUpdate = true;
    }
    if (this.flags !== value) {
      doUpdate = true;
      this.flags = value;
    }
    if (input.value !== value) {
      input.value = value;
    }
    if (doUpdate) {
      this.requestUpdate();
    }
  }

  /**
   * Event handler function for regex flags change events
   *
   * (Used for letting the outside world know the regex has changed
   * and is valid)
   *
   * @param event
   */
  flagChange (event: Event) : void {
    event.preventDefault()
    const input = event.target as HTMLInputElement;
    const value = this._cleanFlags(input.value)

    if (this.flags !== value) {
      // Flags have actually changed so let the outside world know
      this.flags = value;
      this._setWholeRegex()

      this.dispatchEvent(
        new Event('change', { bubbles: true, composed: true })
      )
    }
  }

  //  END:  Private helper methods
  // --------------------------------------------
  // START: Public methods

  /**
   * Render the input field
   *
   * @returns {html}
   */
  render() {
    // console.group('render()')
    this._doInit();

    const regexClass = (this.regexError !== '')
      ? ' has-error'
      : ''

    const flagsClass = (this._flagErrors.length > 0)
      ? ' has-error'
      : ''

    const allErrors = (this.regexError !== '')
      ? [this.regexError, ...this._flagErrors]
      : [...this._flagErrors]

    const errors = (allErrors.length > 0)
      ? html`
      <ul class="errors">
        ${allErrors.map(error => html`<li>${error}</li>`)}
      </ul>`
      : '';

    const flags = (this.noFlags === false)
      ? html`<!--
        --><label for="${this.fieldid}_regex" class="sr-only">Flags</label><!--
        --><input type="text" id="${this.fieldid}_flags" name="${this.fieldid}_flags" class="regex-flags${flagsClass}" placeholder="ig" minlength="7" .value="${this.flags}" style="width: ${this._flagSize}rem" @keyup=${this.flagKeyup} @change=${this.flagChange} />`
      : ''

    return html`
      ${errors}
      <span class="wrap">
        <label for="${this.fieldid}_regex" class="sr-only">Regular expression</label>
        <span class="regex">${this._delimOpen}<!--
        --><input type="text" id="${this.fieldid}_regex" name="${this.fieldid}_regex" class="regex-pattern${regexClass}" placeholder=".*" minlength="${this.maxlength}" .value="${this.value}" @change=${this.valueChange} @keyup=${this.valueKeyup} style="width: ${this._regexSize}rem" />${this._delimClose}</span><!--
        -->${flags}
      </span>`;
  }
}
